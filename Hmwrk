#Task 1

#Modify the `depth-first search` to produce strongly connected components.

#Task 2

#Using breadth-first search write an algorithm that can determine the shortest path from each vertex to every other vertex.
This is called the all-pairs shortest path problem.

from collections import deque

def shortest_paths_bfs(graph):
    shortest_paths = {} #пустий словник, аггрегант для найкоротших шляхів

    for v in graph:
        distances = {} #пустий словник аггрегант для зберігання відстаней від v до інших вершин
        queue = deque() #пуста черга для траверсії в ширину

        queue.append(v)
        distances[v] = 0 #задали початкову відстань 0

        while queue:
            current = queue.popleft()

            for neighbor in graph[current]:
                if neighbor not in distances or distances[current] + 1 < distances[neighbor]:
                    queue.append(neighbor)
                    distances[neighbor] = distances[current] + 1
                    shortest_paths[(v, neighbor)] = shortest_paths.get((v, current), []) + [neighbor]

    return shortest_paths


input'ом функції shortest_paths_bfs є граф, представлений у вигляді словника, в якому ключами є вершини (vertex), а значеннями (values) є списки сусідніх вершин. 
 output'ом є словник shortest_paths, що містить найкоротші шляхи від кожної вершини v до інших вершин графа. Шляхи збережені у вигляді списків вершин.
це - варіант вирішення задачі пошуку найкоротших шляхів між вершинами незваженого графу. 

Для пошуку найкоротших шляхів між вершинами для зваженого (weighted graph) можна застосовувати Floyd-Warshall алгоритм 
з використанням гніздового словнику і матриці.

def all_pairs_shortest_path(graph):
    n = len(graph)
    dist = [[float('inf') for _ in range(n)] for _ in range(n)]

    # Initialize the distance matrix with the direct edge weights
    for i in range(n):
        for j in range(n):
            if i == j:
                dist[i][j] = 0
            elif j in graph[i]:
                dist[i][j] = graph[i][j]

    # Compute the shortest path between each pair of vertices
    for k in range(n):
        for i in range(n):
            for j in range(n):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    return dist

# приклад зваженого графу з 5 вершинами, де вага ребер це values гніздового словника. 
graph = {
    0: {1: 3, 2: 8},
    1: {2: -2},
    2: {3: 2, 4: 1},
    3: {0: 4},
    4: {3: -5}
}

# рахуємо накоротші шляхи всіх пар
shortest_paths = all_pairs_shortest_path(graph)

#виводимо їх на print
n = len(graph)
for i in range(n):
    for j in range(n):
        print(f"Shortest path from {i} to {j}: {shortest_paths[i][j]}")

Функція all_pairs_shortest_path приймає граф, представлений у вигляді гніздового словника, в якому ключі - це вершини, а значення - словники, що представляють вихідні ребра та їх вагу (weight). 
Функція повертає 2D матрицю відстаней dist, де dist[i][j] і є найкоротшою відстанню між вершинами i та j.
